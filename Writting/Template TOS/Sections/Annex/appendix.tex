\cleardoublepage
\renewcommand{\thesection}{\Alph{section}}
\begin{appendices}

\section{\emph{aomenc} Configuration Options} \label{app:libaom}
\begin{lstlisting}

Usage: ./aomenc <options> -o dst_filename src_filename 

Options:
            --help                      Show usage options and exit
-c <arg>,   --cfg=<arg>                 Config file to use
-D,         --debug                     Debug mode (makes output deterministic)
-o <arg>,   --output=<arg>              Output filename
            --codec=<arg>               Codec to use
-p <arg>,   --passes=<arg>              Number of passes (1/2)
            --pass=<arg>                Pass to execute (1/2)
            --fpf=<arg>                 First pass statistics file name
            --limit=<arg>               Stop encoding after n input frames
            --skip=<arg>                Skip the first n input frames
            --good                      Use Good Quality Deadline
-q,         --quiet                     Do not print encode progress
-v,         --verbose                   Show encoder parameters
            --psnr                      Show PSNR in status line
            --webm                      Output WebM (default when WebM IO is enabled)
            --ivf                       Output IVF
            --obu                       Output OBU
-P,         --output-partitions         Makes encoder output partitions. Requires IVF output!
            --q-hist=<arg>              Show quantizer histogram (n-buckets)
            --rate-hist=<arg>           Show rate histogram (n-buckets)
            --disable-warnings          Disable warnings about potentially incorrect encode settings.
-y,         --disable-warning-prompt    Display warnings, but do not prompt user to continue.
            --test-decode=<arg>         Test encode/decode mismatch
                                        off, fatal, warn

Encoder Global Options:
            --yv12                      Input file is YV12 
            --i420                      Input file is I420 (default)
            --i422                      Input file is I422
            --i444                      Input file is I444
-u <arg>,   --usage=<arg>               Usage profile number to use
-t <arg>,   --threads=<arg>             Max number of threads to use
            --profile=<arg>             Bitstream profile number to use
-w <arg>,   --width=<arg>               Frame width
-h <arg>,   --height=<arg>              Frame height
            --forced_max_frame_width    Maximum frame width value to force
            --forced_max_frame_height   Maximum frame height value to force
            --stereo-mode=<arg>         Stereo 3D video format
                                        mono, left-right, bottom-top, top-bottom, right-left
            --timebase=<arg>            Output timestamp precision (fractional seconds)
            --fps=<arg>                 Stream frame rate (rate/scale)
            --global-error-resilient=<  Enable global error resiliency features
-b <arg>,   --bit-depth=<arg>           Bit depth for codec (8 for version <=1, 10 or 12 for version 2)
                                        8, 10, 12
            --lag-in-frames=<arg>       Max number of frames to lag
            --large-scale-tile=<arg>    Large scale tile coding (0: off (default), 1: on)
            --monochrome                Monochrome video (no chroma planes)
            --full-still-picture-hdr    Use full header for still picture

Rate Control Options:
            --drop-frame=<arg>          Temporal resampling threshold (buf %)
            --resize-mode=<arg>         Frame resize mode
            --resize-denominator=<arg>  Frame resize denominator
            --resize-kf-denominator=<a  Frame resize keyframe denominator
            --superres-mode=<arg>       Frame super-resolution mode
            --superres-denominator=<ar  Frame super-resolution denominator
            --superres-kf-denominator=  Frame super-resolution keyframe denominator
            --superres-qthresh=<arg>    Frame super-resolution qindex threshold
            --superres-kf-qthresh=<arg  Frame super-resolution keyframe qindex threshold
            --end-usage=<arg>           Rate control mode
                                        vbr, cbr, cq, q
            --target-bitrate=<arg>      Bitrate (kbps)
            --min-q=<arg>               Minimum (best) quantizer
            --max-q=<arg>               Maximum (worst) quantizer
            --undershoot-pct=<arg>      Datarate undershoot (min) target (%)
            --overshoot-pct=<arg>       Datarate overshoot (max) target (%)
            --buf-sz=<arg>              Client buffer size (ms)
            --buf-initial-sz=<arg>      Client initial buffer size (ms)
            --buf-optimal-sz=<arg>      Client optimal buffer size (ms)

Twopass Rate Control Options:
            --bias-pct=<arg>            CBR/VBR bias (0=CBR, 100=VBR)
            --minsection-pct=<arg>      GOP min bitrate (% of target)
            --maxsection-pct=<arg>      GOP max bitrate (% of target)

Keyframe Placement Options:
            --enable-fwd-kf=<arg>       Enable forward reference keyframes
            --kf-min-dist=<arg>         Minimum keyframe interval (frames)
            --kf-max-dist=<arg>         Maximum keyframe interval (frames)
            --disable-kf                Disable keyframe placement

AV1 Specific Options:
            --cpu-used=<arg>            CPU Used (0..8)
            --dev-sf=<arg>              Dev Speed (0..255)
            --auto-alt-ref=<arg>        Enable automatic alt reference frames
            --sharpness=<arg>           Loop filter sharpness (0..7)
            --static-thresh=<arg>       Motion detection threshold
            --single-tile-decoding=<ar  Single tile decoding (0: off (default), 1: on)
            --tile-columns=<arg>        Number of tile columns to use, log2
            --tile-rows=<arg>           Number of tile rows to use, log2 (set to 0 while threads > 1)
            --arnr-maxframes=<arg>      AltRef max frames (0..15)
            --arnr-strength=<arg>       AltRef filter strength (0..6)
            --tune=<arg>                Distortion metric tuned with
                                        psnr, ssim, cdef-dist, daala-dist
            --cq-level=<arg>            Constant/Constrained Quality level
            --max-intra-rate=<arg>      Max I-frame bitrate (pct)
            --max-inter-rate=<arg>      Max P-frame bitrate (pct)
            --gf-cbr-boost=<arg>        Boost for Golden Frame in CBR mode (pct)
            --lossless=<arg>            Lossless mode (0: false (default), 1: true)
            --enable-cdef=<arg>         Enable the constrained directional enhancement filter (0: false, 1: true (default))
            --enable-restoration=<arg>  Enable the loop restoration filter (0: false, 1: true (default))
            --disable-trellis-quant=<a  Disable trellis optimization of quantized coefficients (0: false (default) 1: true)
            --enable-qm=<arg>           Enable quantisation matrices (0: false (default), 1: true)
            --qm-min=<arg>              Min quant matrix flatness (0..15), default is 8
            --qm-max=<arg>              Max quant matrix flatness (0..15), default is 15
            --enable-dist-8x8=<arg>     Enable dist-8x8 (0: false (default), 1: true)
            --frame-parallel=<arg>      Enable frame parallel decodability features (0: false (default), 1: true)
            --error-resilient=<arg>     Enable error resilient features (0: false (default), 1: true)
            --aq-mode=<arg>             Adaptive quantization mode (0: off (default), 1: variance 2: complexity, 3: cyclic refresh)
            --deltaq-mode=<arg>         Delta qindex mode (0: off (default), 1: deltaq 2: deltaq + deltalf)
            --frame-boost=<arg>         Enable frame periodic boost (0: off (default), 1: on)
            --noise-sensitivity=<arg>   Noise sensitivity (frames to blur)
            --tune-content=<arg>        Tune content type
                                        default, screen
            --cdf-update-mode=<arg>     CDF update mode for entropy coding (0: no CDF update; 1: update CDF on all frames(default); 2: selectively update CDF on some frames
            --color-primaries=<arg>     Color primaries (CICP) of input content:
                                        bt709, unspecified, bt601, bt470m, bt470bg, smpte240, film, bt2020, xyz, smpte431, smpte432, ebu3213
            --transfer-characteristics  Transfer characteristics (CICP) of input content:
                                        unspecified, bt709, bt470m, bt470bg, bt601, smpte240, lin, log100, log100sq10, iec61966, bt1361, srgb, bt2020-10bit, bt2020-12bit, smpte2084, hlg, smpte428
            --matrix-coefficients=<arg  Matrix coefficients (CICP) of input content:
                                        identity, bt709, unspecified, fcc73, bt470bg, bt601, smpte240, ycgco, bt2020ncl, bt2020cl, smpte2085, chromncl, chromcl, ictcp
            --chroma-sample-position=<  The chroma sample position when chroma 4:2:0 is signaled:
                                        unknown, vertical, colocated
            --min-gf-interval=<arg>     min gf/arf frame interval (default 0, indicating in-built behavior)
            --max-gf-interval=<arg>     max gf/arf frame interval (default 0, indicating in-built behavior)
            --sb-size=<arg>             Superblock size to use
                                        dynamic, 64, 128
            --num-tile-groups=<arg>     Maximum number of tile groups, default is 1
            --mtu-size=<arg>            MTU size for a tile group, default is 0 (no MTU targeting), overrides maximum number of tile groups
            --timing-info=<arg>         Signal timing info in the bitstream (model unly works for no hidden frames, no super-res yet):
                                        unspecified, constant, model
            --film-grain-test=<arg>     Film grain test vectors (0: none (default), 1: test-1  2: test-2, ... 16: test-16)
            --film-grain-table=<arg>    Path to file containing film grain parameters
            --enable-ref-frame-mvs=<ar  Enable temporal mv prediction (default is 1)
-b <arg>, --bit-depth=<arg>           Bit depth for codec (8 for version <=1, 10 or 12 for version 2)
                                        8, 10, 12
            --input-bit-depth=<arg>     Bit depth of input
            --sframe-dist=<arg>         S-Frame interval (frames)
            --sframe-mode=<arg>         S-Frame insertion mode (1..2)
            --annexb=<arg>              Save as Annex-B

Stream timebase (--timebase):
The desired precision of timestamps in the output, expressed
in fractional seconds. Default is 1/1000.

Included encoders:

av1    - AOMedia Project AV1 Encoder v0.1.0 (default)

    Use --codec to switch to a non-default encoder.
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{DCT8\_1 VHDL Description} \label{app:dct81}
\begin{lstlisting}[style=vhdl]
-- DCT8 Implementation for inetgration with aggregated architecture

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity DCT8_1_I is
port(   -- Data Inputs
    dataIn0     : in    integer;
    dataIn1     : in    integer;
    dataIn2     : in    integer;
    dataIn3     : in    integer;
    dataIn4     : in    integer;
    dataIn5     : in    integer;
    dataIn6     : in    integer;
    dataIn7     : in    integer;
    -- Control Inputs
    res         : in    std_logic;
    en          : in    std_logic;
    clk         : in    std_logic;
    -- Data Outputs
    dataOut0    : out    integer;
    dataOut1    : out    integer;
    dataOut2    : out    integer;
    dataOut3    : out    integer;
    dataOut4    : out    integer;
    dataOut5    : out    integer;
    dataOut6    : out    integer;
    dataOut7    : out    integer;
    -- Control Outputs
    validOut    : out   std_logic
);
end DCT8_1_I;

architecture Behavioral of DCT8_1_I is
begin

stage1:     process(clk, res, en)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    dataOut0 <= 0;
                    dataOut1 <= 0;
                    dataOut2 <= 0;
                    dataOut3 <= 0;
                    dataOut4 <= 0;
                    dataOut5 <= 0;
                    dataOut6 <= 0;
                    dataOut7 <= 0;
                    validOut <= '0';
                elsif(en = '1') then
                    dataOut0 <= dataIn0 + dataIn7;
                    dataOut1 <= dataIn1 + dataIn6;
                    dataOut2 <= dataIn2 + dataIn5;
                    dataOut3 <= dataIn3 + dataIn4;
                    dataOut4 <= dataIn3 - dataIn4;
                    dataOut5 <= dataIn2 - dataIn5;
                    dataOut6 <= dataIn1 - dataIn6;
                    dataOut7 <= dataIn0 - dataIn7;
                    validOut <= '1';
                end if;
            end if;
        end process;
end Behavioral;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{DCT8\_2 VHDL Description} \label{app:dct82}
\begin{lstlisting}[style=vhdl]
-- DCT8 Stage 2 Implementation for integration with aggregated architecture

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity DCT8_2_I is
port(   -- Data Inputs
    dataIn4     : in    integer;
    dataIn5     : in    integer;
    dataIn6     : in    integer;
    dataIn7     : in    integer;
    -- Control Inputs
    res         : in    std_logic;
    en          : in    std_logic;
    clk         : in    std_logic;
    -- Data Outputs
    dataOut4    : out    integer;
    dataOut5    : out    integer;
    dataOut6    : out    integer;
    dataOut7    : out    integer;
    -- Control Outputs
    validOut    : out   std_logic
);
end DCT8_2_I;

architecture Behavioral of DCT8_2_I is
signal s_stg2M5, s_stg2M6       :   integer := 0;
signal s_stg2A5, s_stg2A6       :   integer := 0;
signal s_stg2D5, s_stg2D6       :   integer := 0;
signal s_stg34, s_stg35, s_stg36, s_stg37       :   integer := 0;
signal s_stg4M41, s_stg4M42, s_stg4M51, s_stg4M52, s_stg4M61, s_stg4M62, s_stg4M71, s_stg4M72       :   integer := 0;
signal s_stg4A4, s_stg4A5, s_stg4A6, s_stg4A7       :   integer := 0;
signal s_stage2MEn, s_stage2AEn, s_stage2DEn, s_stage3En, s_stage4MEn, s_stage4AEn, s_valOut       :   std_logic := '0';
begin

stage2M:    process(clk, res, en)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg2M5 <= 0;
                    s_stg2M6 <= 0;
                    s_stage2AEn <= '0';
                elsif(en = '1') then
                    s_stg2M5 <= dataIn5*185;
                    s_stg2M6 <= dataIn6*185;
                    s_stage2AEn <= '1';
                end if;
            end if;
        end process;

stage2A:    process(clk, res, s_stage2AEn)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg2A5 <= 0;
                    s_stg2A6 <= 0;
                    s_stage2DEn <= '0';
                elsif(s_stage2AEn = '1') then
                    s_stg2A5 <= s_stg2M6 - s_stg2M5;
                    s_stg2A6 <= s_stg2M6 + s_stg2M5;
                    s_stage2DEn <= '1';
                end if;
            end if;
        end process;

stage2D:    process(clk, res, s_stage2DEn)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg2D5 <= 0;
                    s_stg2D6 <= 0;
                    s_stage3En <= '0';
                elsif(s_stage2DEn = '1') then
                    s_stg2D5 <= to_integer(shift_right(to_signed(s_stg2A5,32),8));
                    s_stg2D6 <= to_integer(shift_right(to_signed(s_stg2A6,32),8));
                    s_stage3En <= '1';
                end if;
            end if;
        end process;                

stage3:     process(clk, res, s_stage3En)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg34 <= 0;
                    s_stg35 <= 0;
                    s_stg36 <= 0;
                    s_stg37 <= 0;
                    s_stage4MEn <= '0';
                elsif(s_stage3En = '1') then
                    s_stg34 <= dataIn4 + s_stg2D5;
                    s_stg35 <= dataIn4 - s_stg2D5;
                    s_stg36 <= dataIn7 - s_stg2D6;
                    s_stg37 <= dataIn7 + s_stg2D6;
                    s_stage4MEn <= '1';
                end if;
            end if;
        end process;

stage4M:    process(clk, res, s_stage4MEn)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg4M41 <= 0;
                    s_stg4M42 <= 0;
                    s_stg4M51 <= 0;
                    s_stg4M52 <= 0;
                    s_stg4M61 <= 0;
                    s_stg4M62 <= 0;
                    s_stg4M71 <= 0;
                    s_stg4M72 <= 0;
                    s_stage4AEn <= '0';
                elsif(s_stage4MEn = '1') then
                    s_stg4M41 <= s_stg34*56;
                    s_stg4M42 <= s_stg34*252;
                    s_stg4M51 <= s_stg35*147;
                    s_stg4M52 <= s_stg35*216;
                    s_stg4M61 <= s_stg36*147;
                    s_stg4M62 <= s_stg36*216;
                    s_stg4M71 <= s_stg37*56;
                    s_stg4M72 <= s_stg37*252;
                    s_stage4AEn <= '1';
                end if;
            end if;
        end process;

stage4A:    process(clk, res, s_stage4AEn)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    s_stg4A4 <= 0;
                    s_stg4A5 <= 0;
                    s_stg4A6 <= 0;
                    s_stg4A7 <= 0;
                    s_valOut <= '0';
                elsif(s_stage4AEn = '1') then
                    s_stg4A4 <= s_stg4M41 + s_stg4M72;
                    s_stg4A5 <= s_stg4M52 + s_stg4M61;
                    s_stg4A6 <= s_stg4M62 - s_stg4M51;
                    s_stg4A7 <= s_stg4M71 - s_stg4M42;
                    s_valOut <= '1';
                end if;
            end if;
        end process;
        
outReg:     process(clk, res, s_valOut)
        begin
            if(rising_edge(clk)) then
                if(res = '1') then
                    dataOut5 <= 0;
                    dataOut6 <= 0;
                    dataOut7 <= 0;
                    validOut <= '0';
                elsif(s_valOut = '1') then
                    dataOut4 <= to_integer(shift_right(to_signed(s_stg4A4,32),8));
                    dataOut5 <= to_integer(shift_right(to_signed(s_stg4A5,32),8));
                    dataOut6 <= to_integer(shift_right(to_signed(s_stg4A6,32),8));
                    dataOut7 <= to_integer(shift_right(to_signed(s_stg4A7,32),8));
                    validOut <= '1';
                end if;
            end if;
        end process;
end Behavioral;
\end{lstlisting}
\end{appendices}