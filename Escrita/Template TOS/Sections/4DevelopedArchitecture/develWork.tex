\cleardoublepage
\chapter{Developed Architectures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objectives and Workflow}

The previous chapter presented some characteristics of the current state of \emph{libaom}'s \emph{Transform} stage which might compromise the overall performance of this stage, the most relevant of which being the unnecessary flexibility in the representation of the cosine approximations.

With these imperfections in mind, some tests were performed, in order to come to solutions that would correct some of the presented characteristics.

The developed implementations tackled the forward \emph{DCT}, since it was the \emph{kernel} that would have the most impact on encoder performance, and due to the increased literature over the following kernels. As mentioned previously, the inverse \emph{DCT} acts with accordance with the established standard, no changes can be implemented.

Each of the performed tests intended to draw conclusions over how to correct each of the encountered issues.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transform Matrix Scaling}

To get a baseline on the design choices of the current implementation, the first test was the application of the simplest integer \emph{DCT}. By this, it is meant that each output vector is calculated by the multiplication of a scaled up version of the \emph{forward transformation matrix} ($F$) generated by equation \ref{eq:DCT2} (\emph{DCT-II} kernel), and then rescaled to the original proportion.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integer Transform Matrix}

The integer forward transform matrix is shown in equation \ref{eq:matscale}.

\begin{equation} \label{eq:matscale}
    \begin{gathered}
        F_{x,u} = \beta(u)\cos\left(\frac{(2x+1)u\pi }{2L}\right)\,0\leq u,x < L \\
        \Downarrow \\
        F           = \sqrt{\frac{2}{L}}  \begin{bmatrix}
            \sqrt{\frac{1}{2}}                                  & \sqrt{\frac{1}{2}}                                & \dots & \sqrt{\frac{1}{2}} \\
            \cos\left(\frac{\pi}{2L}\right)    & \cos\left(\frac{3\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)\pi}{2L}\right) \\
            \vdots     & \vdots     & \dots & \vdots       \\
            \cos\left(\frac{(L-1)\pi}{2L}\right)    & \cos\left(\frac{3(L-1)\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)(L-1)\pi}{2L}\right) \\
        \end{bmatrix} 
    \end{gathered}
\end{equation}
With $F$, the integer approximation with $K$ bit scaling is achieved with 
\begin{equation} \label{eq:matscale}
    \nint*{F_K}   = \nint*{2^K \sqrt{\frac{2}{L}}    \begin{bmatrix}
                                        \sqrt{\frac{1}{2}}                                  & \sqrt{\frac{1}{2}}                                & \dots & \sqrt{\frac{1}{2}} \\
                                        \cos\left(\frac{\pi}{2L}\right)    & \cos\left(\frac{3\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)\pi}{2L}\right) \\
                                        \vdots     & \vdots     & \dots & \vdots       \\
                                        \cos\left(\frac{(L-1)\pi}{2L}\right)    & \cos\left(\frac{3(L-1)\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)(L-1)\pi}{2L}\right) \\
                                \end{bmatrix} 
                }
\end{equation}

The transform operation of a residue vector, $g(x)$, becomes

\begin{equation}
    G(u) = \left(\nint*{F_K} g(x)\right)>>K
\end{equation}
%\nint*{F_{x,u}}_K = \nint*{\beta(u)\cos\left(\frac{(2x+1)u\pi }{2L}\right)},0\leq u,x < L 