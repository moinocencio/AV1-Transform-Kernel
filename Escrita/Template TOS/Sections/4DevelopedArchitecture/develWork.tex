\cleardoublepage
\chapter{Developed Architectures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Objectives and Workflow}

The previous chapter presented some characteristics of the current state of \emph{libaom}'s \emph{Transform} stage which might compromise its performance, the most relevant being the unnecessary flexibility in the representation of cosine approximations.

In order to undertake these opportunities, and improve the overall encoder performance, new architectures for the studied stage were developed.

The developed implementations tackled the forward \emph{DCT}, since it was the \emph{kernel} that would have the most impact on encoder performance. As the \emph{IDCT} is shared between encoder and decoder, and due to the added complexity, no changes were done to this block, as it acts with accordance with the established standard, as mentioned previously. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrix Multiplication Implementation}

%To get a baseline on the design choices of the current implementation, the first test was the application of the simplest integer \emph{DCT}. By this, it is meant that each output vector is calculated as the multiplication of a scaled up version of the \emph{forward transformation matrix} ($F$) generated by equation \ref{eq:DCT2} (\emph{DCT-II} kernel), and then rescaled to the original proportion.

The 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integer Transform Matrix}

The integer forward transform matrix is shown in equation \ref{eq:matscale}.

\begin{equation} \label{eq:matscale}
    \begin{gathered}
        F_{x,u} = \beta(u)\cos\left(\frac{(2x+1)u\pi }{2L}\right)\,0\leq u,x < L \\
        \Downarrow \\
        F           = \sqrt{\frac{2}{L}}  \begin{bmatrix}
            \sqrt{\frac{1}{2}}                                  & \sqrt{\frac{1}{2}}                                & \dots & \sqrt{\frac{1}{2}} \\
            \cos\left(\frac{\pi}{2L}\right)    & \cos\left(\frac{3\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)\pi}{2L}\right) \\
            \vdots     & \vdots     & \dots & \vdots       \\
            \cos\left(\frac{(L-1)\pi}{2L}\right)    & \cos\left(\frac{3(L-1)\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)(L-1)\pi}{2L}\right) \\
        \end{bmatrix} 
    \end{gathered}
\end{equation}
With $F$, the integer approximation with $K$ bit scaling is achieved with 
\begin{equation} \label{eq:matscale}
    \nint*{F_K}   = \nint*{2^K \sqrt{\frac{2}{L}}    \begin{bmatrix}
                                        \sqrt{\frac{1}{2}}                                  & \sqrt{\frac{1}{2}}                                & \dots & \sqrt{\frac{1}{2}} \\
                                        \cos\left(\frac{\pi}{2L}\right)    & \cos\left(\frac{3\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)\pi}{2L}\right) \\
                                        \vdots     & \vdots     & \dots & \vdots       \\
                                        \cos\left(\frac{(L-1)\pi}{2L}\right)    & \cos\left(\frac{3(L-1)\pi}{2L}\right) & \dots & \cos\left(\frac{(2(L-1)+1)(L-1)\pi}{2L}\right) \\
                                \end{bmatrix} 
                }
\end{equation}

The transform operation of a residue vector, $g(x)$, becomes

\begin{equation}
    G(u) = \left(\nint*{F_K} g(x)\right)>>K
\end{equation}
%\nint*{F_{x,u}}_K = \nint*{\beta(u)\cos\left(\frac{(2x+1)u\pi }{2L}\right)},0\leq u,x < L 